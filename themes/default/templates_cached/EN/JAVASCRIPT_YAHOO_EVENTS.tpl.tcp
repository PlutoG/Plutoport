<?php
return unserialize("a:6:{i:0;a:1:{i:0;a:5:{i:0;s:31:\"tcpfunc_JAVASCRIPT_YAHOO_EVENTS\";i:1;a:0:{}i:2;i:1;i:3;s:0:\"\";i:4;s:0:\"\";}}i:1;a:0:{}i:2;s:23:\"JAVASCRIPT_YAHOO_EVENTS\";i:3;N;i:4;N;i:5;s:27112:\"\$TPL_FUNCS['tcpfunc_JAVASCRIPT_YAHOO_EVENTS']=\" echo \\\"/*\\\\nSoftware License Agreement (BSD License)\\\\n\\\\nCopyright (c) 2006\\\",\\n	',',\\n	\\\" Yahoo! Inc.\\\\nAll rights reserved.\\\\n\\\\nRedistribution and use of this software in source and binary forms\\\",\\n	',',\\n	\\\" with\\\\nor without modification\\\",\\n	',',\\n	\\\" are permitted provided that the following \\\\nconditions are met:\\\\n\\\\n* Redistributions of source code must retain the above\\\\n  copyright notice\\\",\\n	',',\\n	\\\" this list of conditions and the\\\\n  following disclaimer.\\\\n\\\\n* Redistributions in binary form must reproduce the above\\\\n  copyright notice\\\",\\n	',',\\n	\\\" this list of conditions and the\\\\n  following disclaimer in the documentation and/or other\\\\n  materials provided with the distribution.\\\\n\\\\n* Neither the name of Yahoo! Inc. nor the names of its\\\\n  contributors may be used to endorse or promote products\\\\n  derived from this software without specific prior\\\\n  written permission of Yahoo! Inc.\\\\n\\\\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \\\\\\\"AS \\\\nIS\\\\\\\" AND ANY EXPRESS OR IMPLIED WARRANTIES\\\",\\n	',',\\n	\\\" INCLUDING\\\",\\n	',',\\n	\\\" BUT NOT LIMITED \\\\nTO\\\",\\n	',',\\n	\\\" THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A \\\\nPARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER \\\\nOR CONTRIBUTORS BE LIABLE FOR ANY DIRECT\\\",\\n	',',\\n	\\\" INDIRECT\\\",\\n	',',\\n	\\\" INCIDENTAL\\\",\\n	',',\\n	\\\" SPECIAL\\\",\\n	',',\\n	\\\"\\\\nEXEMPLARY\\\",\\n	',',\\n	\\\" OR CONSEQUENTIAL DAMAGES (INCLUDING\\\",\\n	',',\\n	\\\" BUT NOT LIMITED TO\\\",\\n	',',\\n	\\\" \\\\nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE\\\",\\n	',',\\n	\\\" DATA\\\",\\n	',',\\n	\\\" OR \\\\nPROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF \\\\nLIABILITY\\\",\\n	',',\\n	\\\" WHETHER IN CONTRACT\\\",\\n	',',\\n	\\\" STRICT LIABILITY\\\",\\n	',',\\n	\\\" OR TORT (INCLUDING \\\\nNEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS \\\\nSOFTWARE\\\",\\n	',',\\n	\\\" EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\\\\n*/\\\\n\\\\n// Only load this library once.  If it is loaded a second time\\\",\\n	',',\\n	\\\" existing\\\\n// events cannot be detached.\\\\nfunction yahoo_events_init() {\\\\nif (typeof window.YAHOO=='undefined') // Yahoo not loaded yet. Probably this is all loading via AJAX which cannot guarantee load order\\\\n{\\\\n	window.setTimeout(yahoo_events_init\\\",\\n	',',\\n	\\\"100);\\\\n	return;\\\\n\\\",\\n	\\\"}\\\",\\n	\\\"\\\\nif (!YAHOO.util.Event) {\\\\n\\\\n/**\\\\n * The event utility provides functions to add and remove event listeners\\\",\\n	',',\\n	\\\"\\\\n * event cleansing.  It also tries to automatically remove listeners it\\\\n * registers during the unload event.\\\\n * @class\\\\n * @constructor\\\\n */\\\\n	 var tmp_function=function() {\\\\n\\\\n		  /**\\\\n			* True after the onload event has fired\\\\n			* @type boolean\\\\n			* @private\\\\n			*/\\\\n		  var loadComplete =  false;\\\\n\\\\n		  /**\\\\n			* Cache of wrapped listeners\\\\n			* @type array\\\\n			* @private\\\\n			*/\\\\n		  var listeners = [];\\\\n\\\\n		  /**\\\\n			* Listeners that will be attached during the onload event\\\\n			* @type array\\\\n			* @private\\\\n			*/\\\\n		  var delayedListeners = [];\\\\n\\\\n		  /**\\\\n			* User-defined unload function that will be fired before all events\\\\n			* are detached\\\\n			* @type array\\\\n			* @private\\\\n			*/\\\\n		  var unloadListeners = [];\\\\n\\\\n		  /**\\\\n			* Cache of the custom events that have been defined.  Used for\\\\n			* automatic cleanup\\\\n			* @type array\\\\n			* @private\\\\n			*/\\\\n		  var customEvents = [];\\\\n\\\\n		  /**\\\\n			* Cache of DOM0 event handlers to work around issues with DOM2 events\\\\n			* in Safari\\\\n			* @private\\\\n			*/\\\\n		  var legacyEvents = [];\\\\n\\\\n		  /**\\\\n			* Listener stack for DOM0 events\\\\n			* @private\\\\n			*/\\\\n		  var legacyHandlers = [];\\\\n\\\\n		  return { // PREPROCESS\\\\n\\\\n				/**\\\\n				 * Element to bind\\\",\\n	',',\\n	\\\" int constant\\\\n				 * @type int\\\\n				 */\\\\n				EL: 0\\\",\\n	',',\\n	\\\"\\\\n\\\\n				/**\\\\n				 * Type of event\\\",\\n	',',\\n	\\\" int constant\\\\n				 * @type int\\\\n				 */\\\\n				TYPE: 1\\\",\\n	',',\\n	\\\"\\\\n\\\\n				/**\\\\n				 * Function to execute\\\",\\n	',',\\n	\\\" int constant\\\\n				 * @type int\\\\n				 */\\\\n				FN: 2\\\",\\n	',',\\n	\\\"\\\\n\\\\n				/**\\\\n				 * Function wrapped for scope correction and cleanup\\\",\\n	',',\\n	\\\" int constant\\\\n				 * @type int\\\\n				 */\\\\n				WFN: 3\\\",\\n	',',\\n	\\\"\\\\n\\\\n				/**\\\\n				 * Object passed in by the user that will be returned as a \\\\n				 * parameter to the callback\\\",\\n	',',\\n	\\\" int constant\\\\n				 * @type int\\\\n				 */\\\\n				SCOPE: 3\\\",\\n	',',\\n	\\\"\\\\n\\\\n				/**\\\\n				 * Adjusted scope\\\",\\n	',',\\n	\\\" either the element we are registering the event\\\\n				 * on or the custom object passed in by the listener\\\",\\n	',',\\n	\\\" int constant\\\\n				 * @type int\\\\n				 */\\\\n				ADJ_SCOPE: 4\\\",\\n	',',\\n	\\\"\\\\n\\\\n				/**\\\\n				 * Safari detection is necessary to work around the preventDefault\\\\n				 * bug that makes it so you can't cancel a href click from the \\\\n				 * handler.  There is not a capabilities check we can use here.\\\\n				 * @private\\\\n				 */\\\\n				isSafari: (navigator.userAgent.match(/safari/gi))\\\",\\n	',',\\n	\\\"\\\\n\\\\n				/**\\\\n				 * @private\\\\n				 * IE detection needed to properly calculate pageX and pageY.  \\\\n				 * capabilities checking didn't seem to work because another \\\\n				 * browser that does not provide the properties have the values\\\\n				 * calculated in a different manner than IE.\\\\n				 */\\\\n				isIE: (!this.isSafari && navigator.userAgent.match(/msie/gi))\\\",\\n	',',\\n	\\\"\\\\n\\\\n				/**\\\\n				 * Appends an event handler\\\\n				 *\\\\n				 * @param Object	  el		  The html element to assign the\\\\n				 *									  event to\\\\n				 * @param String	  sType	  The type of event to append\\\\n				 * @param Function	fn		  The method the event invokes\\\\n				 * @param Object	  oScope	 An arbitrary object that will be \\\\n				 *									  passed as a parameter to the handler\\\\n				 * @param boolean	 bOverride If true\\\",\\n	',',\\n	\\\" the obj passed in becomes\\\\n				 *									  the execution scope of the listener\\\\n				 * @return boolean	True if the action was successful or defered\\\",\\n	',',\\n	\\\"\\\\n				 *								false if one or more of the elements \\\\n				 *								could not have the event bound to it.\\\\n				 */\\\\n				addListener: function(el\\\",\\n	',',\\n	\\\" sType\\\",\\n	',',\\n	\\\" fn\\\",\\n	',',\\n	\\\" oScope\\\",\\n	',',\\n	\\\" bOverride) {\\\\n\\\\n					 // The el argument can be an array of elements or element ids.\\\\n					 if ( this._isValidCollection(el)) {\\\\n						  var ok = true;\\\\n						  for (var i=0; i< el.length; ++i) {\\\\n								ok = ( this.on(el[i]\\\",\\n	',',\\n	\\\" \\\\n													sType\\\",\\n	',',\\n	\\\" \\\\n													fn\\\",\\n	',',\\n	\\\" \\\\n													oScope\\\",\\n	',',\\n	\\\" \\\\n													bOverride) && ok );\\\\n						  \\\",\\n	\\\"}\\\",\\n	\\\"\\\\n						  return ok;\\\\n\\\\n					 \\\",\\n	\\\"}\\\",\\n	\\\" else if (typeof el == \\\\\\\"string\\\\\\\") {\\\\n						  // If the el argument is a string\\\",\\n	',',\\n	\\\" we assume it is \\\\n						  // actually the id of the element.  If the page is loaded\\\\n						  // we convert el to the actual element\\\",\\n	',',\\n	\\\" otherwise we \\\\n						  // defer attaching the event until onload event fires\\\\n\\\\n						  // check to see if we need to delay hooking up the event \\\\n						  // until after the page loads.\\\\n						  if (loadComplete) {\\\\n								el = this.getEl(el);\\\\n						  \\\",\\n	\\\"}\\\",\\n	\\\" else {\\\\n								// defer adding the event until onload fires\\\\n								delayedListeners[delayedListeners.length] =\\\\n									 [el\\\",\\n	',',\\n	\\\" sType\\\",\\n	',',\\n	\\\" fn\\\",\\n	',',\\n	\\\" oScope\\\",\\n	',',\\n	\\\" bOverride];\\\\n\\\\n								return true;\\\\n						  \\\",\\n	\\\"}\\\",\\n	\\\"\\\\n					 \\\",\\n	\\\"}\\\",\\n	\\\"\\\\n\\\\n					 // Element should be an html element or an array if we get \\\\n					 // here.\\\\n					 if (!el) {\\\\n						  // this.logger.debug(\\\\\\\"unable to attach event \\\\\\\" + sType);\\\\n						  return false;\\\\n					 \\\",\\n	\\\"}\\\",\\n	\\\"\\\\n\\\\n					 // we need to make sure we fire registered unload events \\\\n					 // prior to automatically unhooking them.  So we hang on to \\\\n					 // these instead of attaching them to the window and fire the\\\\n					 // handles explicitly during our one unload event.\\\\n					 if (\\\\\\\"unload\\\\\\\" == sType && oScope !== this) {\\\\n						  unloadListeners[unloadListeners.length] =\\\\n									 [el\\\",\\n	',',\\n	\\\" sType\\\",\\n	',',\\n	\\\" fn\\\",\\n	',',\\n	\\\" oScope\\\",\\n	',',\\n	\\\" bOverride];\\\\n						  return true;\\\\n					 \\\",\\n	\\\"}\\\",\\n	\\\"\\\\n\\\\n					 // this.logger.debug(\\\\\\\"Adding handler: \\\\\\\" + el + \\\\\\\"\\\",\\n	',',\\n	\\\" \\\\\\\" + sType);\\\\n\\\\n					 // if the user chooses to override the scope\\\",\\n	',',\\n	\\\" we use the custom\\\\n					 // object passed in\\\",\\n	',',\\n	\\\" otherwise the executing scope will be the\\\\n					 // HTML element that the event is registered on\\\\n					 var scope = (bOverride) ? oScope : el;\\\\n\\\\n					 // wrap the function so we can return the oScope object when\\\\n					 // the event fires;\\\\n					 var wrappedFn = function(e) {\\\\n								return fn.call(scope\\\",\\n	',',\\n	\\\" YAHOO.util.Event.getEvent(e)\\\",\\n	',',\\n	\\\" \\\\n										  oScope);\\\\n						  \\\",\\n	\\\"}\\\",\\n	\\\";\\\\n\\\\n					 var li = [el\\\",\\n	',',\\n	\\\" sType\\\",\\n	',',\\n	\\\" fn\\\",\\n	',',\\n	\\\" wrappedFn\\\",\\n	',',\\n	\\\" scope];\\\\n					 var index = listeners.length;\\\\n					 // cache the listener so we can try to automatically unload\\\\n					 listeners[index] = li;\\\\n\\\\n					 if (this.useLegacyEvent(el\\\",\\n	',',\\n	\\\" sType)) {\\\\n						  var legacyIndex = this.getLegacyIndex(el\\\",\\n	',',\\n	\\\" sType);\\\\n						  if (legacyIndex == -1) {\\\\n\\\\n								legacyIndex = legacyEvents.length;\\\\n								// cache the signature for the DOM0 event\\\",\\n	',',\\n	\\\" and \\\\n								// include the existing handler for the event\\\",\\n	',',\\n	\\\" if any\\\\n								legacyEvents[legacyIndex] =\\\\n									 [el\\\",\\n	',',\\n	\\\" sType\\\",\\n	',',\\n	\\\" el[\\\\\\\"on\\\\\\\" + sType]];\\\\n								legacyHandlers[legacyIndex] = [];\\\\n\\\\n								el[\\\\\\\"on\\\\\\\" + sType] = \\\\n									 function(e) {\\\\n										  YAHOO.util.Event.fireLegacyEvent(\\\\n												YAHOO.util.Event.getEvent(e)\\\",\\n	',',\\n	\\\" legacyIndex);\\\\n									 \\\",\\n	\\\"}\\\",\\n	\\\";\\\\n						  \\\",\\n	\\\"}\\\",\\n	\\\"\\\\n\\\\n						  // add a reference to the wrapped listener to our custom\\\\n						  // stack of events\\\\n						  legacyHandlers[legacyIndex].push(index);\\\\n\\\\n					 // DOM2 Event model\\\\n					 \\\",\\n	\\\"}\\\",\\n	\\\" else if (typeof el.addEventListener!='undefined') {\\\\n						  // this.logger.debug(\\\\\\\"adding DOM event: \\\\\\\" + el.id + \\\\n						  // \\\\\\\"\\\",\\n	',',\\n	\\\" \\\\\\\" + sType);\\\\n						  el.addEventListener(sType\\\",\\n	',',\\n	\\\" wrappedFn\\\",\\n	',',\\n	\\\" false);\\\\n					 // Internet Explorer abstraction\\\\n					 \\\",\\n	\\\"}\\\",\\n	\\\" else if (typeof el.attachEvent!='undefined') {\\\\n						  el.attachEvent(\\\\\\\"on\\\\\\\" + sType\\\",\\n	',',\\n	\\\" wrappedFn);\\\\n					 \\\",\\n	\\\"}\\\",\\n	\\\"\\\\n\\\\n					 return true;\\\\n					 \\\\n				\\\",\\n	\\\"}\\\",\\n	',',\\n	\\\"\\\\n\\\\n				/**\\\\n				 * Shorthand for YAHOO.util.Event.addListener\\\\n				 * @type function\\\\n				 */\\\\n				// on: this.addListener\\\",\\n	',',\\n	\\\"\\\\n\\\\n				/**\\\\n				 * When using legacy events\\\",\\n	',',\\n	\\\" the handler is routed to this object\\\\n				 * so we can fire our custom listener stack.\\\\n				 * @private\\\\n				 */\\\\n				fireLegacyEvent: function(e\\\",\\n	',',\\n	\\\" legacyIndex) {\\\\n					 // alert(\\\\\\\"fireLegacyEvent \\\\\\\" + legacyIndex);\\\\n					 var ok = true;\\\\n\\\\n					 // var el = legacyEvents[YAHOO.util.Event.EL];\\\\n\\\\n					 /* this is not working because the property may get populated\\\\n					 // fire the event we replaced\\\",\\n	',',\\n	\\\" if it exists\\\\n					 var origHandler = legacyEvents[2];\\\\n					 alert(origHandler);\\\\n					 if (origHandler && origHandler.call) {\\\\n						  var ret = origHandler.call(el\\\",\\n	',',\\n	\\\" e);\\\\n						  ok = (ret);\\\\n					 \\\",\\n	\\\"}\\\",\\n	\\\"\\\\n					 */\\\\n\\\\n					 var le = legacyHandlers[legacyIndex];\\\\n					 for (i=0; i < le.length; ++i) {\\\\n						  var index = le[i];\\\\n						  // alert(index);\\\\n						  if (index) {\\\\n								var li = listeners[index];\\\\n								if (typeof li=='undefined') return; // stops error on Chrome\\\\n								var scope = li[this.ADJ_SCOPE];\\\\n								var ret = li[this.WFN].call(scope\\\",\\n	',',\\n	\\\" e);\\\\n								ok = (ok && ret);\\\\n								// alert(ok);\\\\n						  \\\",\\n	\\\"}\\\",\\n	\\\"\\\\n					 \\\",\\n	\\\"}\\\",\\n	\\\"\\\\n\\\\n					 return ok;\\\\n				\\\",\\n	\\\"}\\\",\\n	',',\\n	\\\"\\\\n\\\\n				/**\\\\n				 * Returns the legacy event index that matches the supplied \\\\n				 * signature\\\\n				 * @private\\\\n				 */\\\\n				getLegacyIndex: function(el\\\",\\n	',',\\n	\\\" sType) {\\\\n					 for (var i=0; i < legacyEvents.length; ++i) {\\\\n						  var le = legacyEvents[i];\\\\n						  if (le && le[0] == el && le[1] == sType) {\\\\n								return i;\\\\n						  \\\",\\n	\\\"}\\\",\\n	\\\"\\\\n					 \\\",\\n	\\\"}\\\",\\n	\\\"\\\\n\\\\n					 return -1;\\\\n				\\\",\\n	\\\"}\\\",\\n	',',\\n	\\\"\\\\n\\\\n				/**\\\\n				 * Logic that determines when we should automatically use legacy\\\\n				 * events instead of DOM2 events.\\\\n				 * @private\\\\n				 */\\\\n				useLegacyEvent: function(el\\\",\\n	',',\\n	\\\" sType) {\\\\n\\\\n					 return ( (!el.addEventListener && !el.attachEvent)/* || \\\\n										  (sType == \\\\\\\"click\\\\\\\" && this.isSafari) CHRISFIX*/ );\\\\n				\\\",\\n	\\\"}\\\",\\n	',',\\n	\\\"\\\\n						  \\\\n				/**\\\\n				 * Removes an event handler\\\\n				 *\\\\n				 * @param Object	el the html element or the id of the element to\\\\n				 * assign the event to.\\\\n				 * @param String	sType the type of event to remove\\\\n				 * @param Function	fn the method the event invokes\\\\n				 * @return boolean	true if the unbind was successful\\\",\\n	',',\\n	\\\" false \\\\n				 * otherwise\\\\n				 */\\\\n				removeListener: function(el\\\",\\n	',',\\n	\\\" sType\\\",\\n	',',\\n	\\\" fn) {\\\\n\\\\n					 // The el argument can be a string\\\\n					 if (typeof el == \\\\\\\"string\\\\\\\") {\\\\n						  el = this.getEl(el);\\\\n					 // The el argument can be an array of elements or element ids.\\\\n					 \\\",\\n	\\\"}\\\",\\n	\\\" else if ( this._isValidCollection(el)) {\\\\n						  var ok = true;\\\\n						  for (var i=0; i< el.length; ++i) {\\\\n								ok = ( this.removeListener(el[i]\\\",\\n	',',\\n	\\\" sType\\\",\\n	',',\\n	\\\" fn) && ok );\\\\n						  \\\",\\n	\\\"}\\\",\\n	\\\"\\\\n						  return ok;\\\\n					 \\\",\\n	\\\"}\\\",\\n	\\\"\\\\n\\\\n					 var cacheItem = null;\\\\n					 var index = this._getCacheIndex(el\\\",\\n	',',\\n	\\\" sType\\\",\\n	',',\\n	\\\" fn);\\\\n\\\\n					 if (index >= 0) {\\\\n						  cacheItem = listeners[index];\\\\n					 \\\",\\n	\\\"}\\\",\\n	\\\"\\\\n\\\\n					 if (!el || !cacheItem) {\\\\n						  // this.logger.debug(\\\\\\\"cached listener not found\\\\\\\");\\\\n						  return false;\\\\n					 \\\",\\n	\\\"}\\\",\\n	\\\"\\\\n\\\\n					 // this.logger.debug(\\\\\\\"Removing handler: \\\\\\\" + el + \\\\\\\"\\\",\\n	',',\\n	\\\" \\\\\\\" + sType);\\\\n\\\\n					 if (typeof el.removeEventListener!='undefined') {\\\\n						  el.removeEventListener(sType\\\",\\n	',',\\n	\\\" cacheItem[this.WFN]\\\",\\n	',',\\n	\\\" false);\\\\n						  // alert(\\\\\\\"adsf\\\\\\\");\\\\n					 \\\",\\n	\\\"}\\\",\\n	\\\" else if (typeof el.detachEvent!='undefined') {\\\\n						  el.detachEvent(\\\\\\\"on\\\\\\\" + sType\\\",\\n	',',\\n	\\\" cacheItem[this.WFN]);\\\\n					 \\\",\\n	\\\"}\\\",\\n	\\\"\\\\n\\\\n					 // removed the wrapped handler\\\\n					 delete listeners[index][this.WFN];\\\\n					 delete listeners[index][this.FN];\\\\n					 delete listeners[index];\\\\n\\\\n					 return true;\\\\n\\\\n				\\\",\\n	\\\"}\\\",\\n	',',\\n	\\\"\\\\n\\\\n				/**\\\\n				 * Returns the event's target element\\\\n				 * @param Event	ev the event\\\\n				 * @param boolean	resolveTextNode when set to true the target's\\\\n				 *						parent will be returned if the target is a\\\\n				 *						text node\\\\n				 * @return HTMLElement	the event's target\\\\n				 */\\\\n				getTarget: function(ev\\\",\\n	',',\\n	\\\" resolveTextNode) {\\\\n					 var t = ev.target || ev.srcElement;\\\\n\\\\n					 if (resolveTextNode && t && \\\\\\\"#text\\\\\\\" == t.nodeName) {\\\\n						  // this.logger.debug(\\\\\\\"target is text node\\\",\\n	',',\\n	\\\" returning \\\\n						  // parent\\\\\\\");\\\\n						  return t.parentNode;\\\\n					 \\\",\\n	\\\"}\\\",\\n	\\\" else {\\\\n						  return t;\\\\n					 \\\",\\n	\\\"}\\\",\\n	\\\"\\\\n				\\\",\\n	\\\"}\\\",\\n	',',\\n	\\\"\\\\n\\\\n				/**\\\\n				 * Returns the event's pageX\\\\n				 * @param Event	ev the event\\\\n				 * @return int	the event's pageX\\\\n				 */\\\\n				getPageX: function(ev) {\\\\n					 var x = ev.pageX;\\\\n					 if (!x && 0 !== x) {\\\\n						  x = ev.clientX || 0;\\\\n\\\\n						  if ( this.isIE ) {\\\\n								x += this._getScrollLeft();\\\\n						  \\\",\\n	\\\"}\\\",\\n	\\\"\\\\n					 \\\",\\n	\\\"}\\\",\\n	\\\"\\\\n\\\\n					 return x;\\\\n				\\\",\\n	\\\"}\\\",\\n	',',\\n	\\\"\\\\n\\\\n				/**\\\\n				 * Returns the event's pageY\\\\n				 * @param Event	ev the event\\\\n				 * @return int	the event's pageY\\\\n				 */\\\\n				getPageY: function(ev) {\\\\n					 var y = ev.pageY;\\\\n					 if (!y && 0 !== y) {\\\\n						  y = ev.clientY || 0;\\\\n\\\\n						  if ( this.isIE ) {\\\\n								y += this._getScrollTop();\\\\n						  \\\",\\n	\\\"}\\\",\\n	\\\"\\\\n					 \\\",\\n	\\\"}\\\",\\n	\\\"\\\\n\\\\n\\\\n					 return y;\\\\n				\\\",\\n	\\\"}\\\",\\n	',',\\n	\\\"\\\\n\\\\n				/**\\\\n				 * Returns the event's related target \\\\n				 * @param Event	ev the event\\\\n				 * @return HTMLElement	the event's relatedTarget\\\\n				 */\\\\n				getRelatedTarget: function(ev) {\\\\n					 var t = ev.relatedTarget;\\\\n					 if (!t) {\\\\n						  if (ev.type == \\\\\\\"mouseout\\\\\\\") {\\\\n								t = ev.toElement;\\\\n						  \\\",\\n	\\\"}\\\",\\n	\\\" else if (ev.type == \\\\\\\"mouseover\\\\\\\") {\\\\n								t = ev.fromElement;\\\\n						  \\\",\\n	\\\"}\\\",\\n	\\\"\\\\n					 \\\",\\n	\\\"}\\\",\\n	\\\"\\\\n\\\\n					 return t;\\\\n				\\\",\\n	\\\"}\\\",\\n	',',\\n	\\\"\\\\n\\\\n				/**\\\\n				 * Returns the time of the event.  If the time is not included\\\",\\n	',',\\n	\\\" the\\\\n				 * event is modified using the current time.\\\\n				 * @param Event	ev the event\\\\n				 * @return Date	the time of the event\\\\n				 */\\\\n				getTime: function(ev) {\\\\n					 if (typeof ev.time=='undefined') {\\\\n						  var t = new Date().getTime();\\\\n						  try {\\\\n								ev.time = t;\\\\n						  \\\",\\n	\\\"}\\\",\\n	\\\" catch(e) { \\\\n								// can't set the time property  \\\\n								return t;\\\\n						  \\\",\\n	\\\"}\\\",\\n	\\\"\\\\n					 \\\",\\n	\\\"}\\\",\\n	\\\"\\\\n\\\\n					 return ev.time;\\\\n				\\\",\\n	\\\"}\\\",\\n	',',\\n	\\\"\\\\n\\\\n				/**\\\\n				 * Convenience method for stopPropagation + preventDefault\\\\n				 * @param Event	ev the event\\\\n				 */\\\\n				stopEvent: function(ev) {\\\\n					 this.stopPropagation(ev);\\\\n					 this.preventDefault(ev);\\\\n				\\\",\\n	\\\"}\\\",\\n	',',\\n	\\\"\\\\n\\\\n				/**\\\\n				 * Stops event propagation\\\\n				 * @param Event	ev the event\\\\n				 */\\\\n				stopPropagation: function(ev) {\\\\n					 if (typeof ev.stopPropagation!='undefined') {\\\\n						  ev.stopPropagation();\\\\n					 \\\",\\n	\\\"}\\\",\\n	\\\" else {\\\\n						  ev.cancelBubble = true;\\\\n					 \\\",\\n	\\\"}\\\",\\n	\\\"\\\\n				\\\",\\n	\\\"}\\\",\\n	',',\\n	\\\"\\\\n\\\\n				/**\\\\n				 * Prevents the default behavior of the event\\\\n				 * @param Event	ev the event\\\\n				 */\\\\n				preventDefault: function(ev) {\\\\n					 if (typeof ev.preventDefault!='undefined') {\\\\n						  ev.preventDefault();\\\\n					 \\\",\\n	\\\"}\\\",\\n	\\\" else {\\\\n						  ev.returnValue = false;\\\\n					 \\\",\\n	\\\"}\\\",\\n	\\\"\\\\n				\\\",\\n	\\\"}\\\",\\n	',',\\n	\\\"\\\\n				 \\\\n				/**\\\\n				 * Returns the event\\\",\\n	',',\\n	\\\" should not be necessary for user to call\\\\n				 * @param Event	the event parameter from the handler\\\\n				 * @return Event	the event \\\\n				 */\\\\n				getEvent: function(e) {\\\\n					 var ev = e || window.event;\\\\n\\\\n					 if (!ev) {\\\\n						  var c = this.getEvent.caller;\\\\n						  while (c) {\\\\n								ev = c.arguments[0];\\\\n								if (ev && Event == ev.constructor) {\\\\n									 break;\\\\n								\\\",\\n	\\\"}\\\",\\n	\\\"\\\\n								c = c.caller;\\\\n						  \\\",\\n	\\\"}\\\",\\n	\\\"\\\\n					 \\\",\\n	\\\"}\\\",\\n	\\\"\\\\n\\\\n					 return ev;\\\\n				\\\",\\n	\\\"}\\\",\\n	',',\\n	\\\"\\\\n\\\\n				/**\\\\n				 * Returns the charcode for an event\\\\n				 * @param Event	ev the event\\\\n				 * @return int	the event's charCode\\\\n				 */\\\\n				getCharCode: function(ev) {\\\\n					 return ev.charCode || (ev.type == \\\\\\\"keypress\\\\\\\") ? ev.keyCode : 0;\\\\n				\\\",\\n	\\\"}\\\",\\n	',',\\n	\\\"\\\\n\\\\n				/**\\\\n				 * @private\\\\n				 * Locating the saved event handler data by function ref\\\\n				 */\\\\n				_getCacheIndex: function(el\\\",\\n	',',\\n	\\\" sType\\\",\\n	',',\\n	\\\" fn) {\\\\n					 for (var i=0; i< listeners.length; ++i) {\\\\n						  var li = listeners[i];\\\\n						  if ( li					  && \\\\n								 li[this.FN] == fn  &&\\\\n								 li[this.EL] == el  && \\\\n								 li[this.TYPE] == sType ) {\\\\n								return i;\\\\n						  \\\",\\n	\\\"}\\\",\\n	\\\"\\\\n					 \\\",\\n	\\\"}\\\",\\n	\\\"\\\\n\\\\n					 return -1;\\\\n				\\\",\\n	\\\"}\\\",\\n	',',\\n	\\\"\\\\n\\\\n				/**\\\\n				 * We want to be able to use getElementsByTagName as a collection\\\\n				 * to attach a group of events to.  Unfortunately\\\",\\n	',',\\n	\\\" different \\\\n				 * browsers return different types of collections.  This function\\\\n				 * tests to determine if the object is array-like.  It will also \\\\n				 * fail if the object is an array\\\",\\n	',',\\n	\\\" but is empty.\\\\n				 * @param o the object to test\\\\n				 * @return boolean	true if the object is array-like and populated\\\\n				 */\\\\n				_isValidCollection: function(o) {\\\\n					 // alert(o.constructor.toString())\\\\n					 // alert(typeof o)\\\\n\\\\n					 return ( o						  && // o is something\\\\n								 o.length				 && // o is indexed\\\\n								 typeof o != \\\\\\\"string\\\\\\\" && // o is not a string\\\\n								 !o.tagName			  && // o is not an HTML element\\\\n								 !o.alert				 && // o is not a window\\\\n								 typeof o[0] != \\\\\\\"undefined\\\\\\\" );\\\\n\\\\n				\\\",\\n	\\\"}\\\",\\n	',',\\n	\\\"\\\\n\\\\n				/**\\\\n				 * @private\\\\n				 * DOM element cache\\\\n				 */\\\\n				elCache: {\\\",\\n	\\\"}\\\",\\n	',',\\n	\\\"\\\\n\\\\n				/**\\\\n				 * We cache elements bound by id because when the unload event \\\\n				 * fires\\\",\\n	',',\\n	\\\" we can no longer use document.getElementById\\\\n				 * @private\\\\n				 */\\\\n				getEl: function(id) {\\\\n					 /*\\\\n					 // this is a problem when replaced via document.getElementById\\\\n					 if (! this.elCache[id]) {\\\\n						  try {\\\\n								var el = document.getElementById(id);\\\\n								if (el) {\\\\n									 this.elCache[id] = el;\\\\n								\\\",\\n	\\\"}\\\",\\n	\\\"\\\\n						  \\\",\\n	\\\"}\\\",\\n	\\\" catch (er) {\\\\n								// this.logger.debug(\\\\\\\"document obj not currently \\\\n								// available\\\\\\\");\\\\n						  \\\",\\n	\\\"}\\\",\\n	\\\"\\\\n					 \\\",\\n	\\\"}\\\",\\n	\\\"\\\\n					 return this.elCache[id];\\\\n					 */\\\\n\\\\n					 return document.getElementById(id);\\\\n				\\\",\\n	\\\"}\\\",\\n	',',\\n	\\\"\\\\n\\\\n				/**\\\\n				 * Clears the element cache\\\\n				 */\\\\n				clearCache: function() {\\\\n					 for (i in this.elCache) {\\\\n						  delete this.elCache[i];\\\\n					 \\\",\\n	\\\"}\\\",\\n	\\\"\\\\n				\\\",\\n	\\\"}\\\",\\n	',',\\n	\\\"\\\\n\\\\n				/**\\\\n				 * Called by CustomEvent instances to provide a handle to the \\\\n				 * event * that can be removed later on.  Should be package \\\\n				 * protected.\\\\n				 * @private\\\\n				 */\\\\n				regCE: function(ce) {\\\\n					 customEvents.push(ce);\\\\n				\\\",\\n	\\\"}\\\",\\n	',',\\n	\\\"\\\\n\\\\n				/**\\\\n				 * @private\\\\n				 * hook up any deferred listeners\\\\n				 */\\\\n				_load: function(e) {\\\\n					 // me.logger = new ygLogger(\\\\\\\"pe.Event\\\\\\\");\\\\n					 loadComplete = true;\\\\n				\\\",\\n	\\\"}\\\",\\n	',',\\n	\\\"\\\\n\\\\n				/**\\\\n				 * Polling function that runs before the onload event fires\\\",\\n	',',\\n	\\\" \\\\n				 * attempting * to attach to DOM Nodes as soon as they are \\\\n				 * available\\\\n				 * @private\\\\n				 */\\\\n				_tryPreloadAttach: function() {\\\\n					 // this.logger.debug(\\\\\\\"tryPreloadAttach\\\\\\\");\\\\n\\\\n					 // keep trying until after the page is loaded.  We need to \\\\n					 // check the page load state prior to trying to bind the \\\\n					 // elements so that we can be certain all elements have been \\\\n					 // tested appropriately\\\\n					 var tryAgain = !loadComplete;\\\\n\\\\n					 for (var i=0; i < delayedListeners.length; ++i) {\\\\n						  var d = delayedListeners[i];\\\\n						  // There may be a race condition here\\\",\\n	',',\\n	\\\" so we need to \\\\n						  // verify the array element is usable.\\\\n						  if (d) {\\\\n\\\\n								// el will be null if document.getElementById did not\\\\n								// work\\\\n								var el = this.getEl(d[this.EL]);\\\\n\\\\n								if (el) {\\\\n									 // this.logger.debug(\\\\\\\"attaching: \\\\\\\" + d[this.EL]);\\\\n									 this.on(el\\\",\\n	',',\\n	\\\" d[this.TYPE]\\\",\\n	',',\\n	\\\" d[this.FN]\\\",\\n	',',\\n	\\\" \\\\n												d[this.SCOPE]\\\",\\n	',',\\n	\\\" d[this.ADJ_SCOPE]);\\\\n									 delete delayedListeners[i];\\\\n								\\\",\\n	\\\"}\\\",\\n	\\\"\\\\n						  \\\",\\n	\\\"}\\\",\\n	\\\"\\\\n					 \\\",\\n	\\\"}\\\",\\n	\\\"\\\\n\\\\n					 if (tryAgain) {\\\\n						  setTimeout(\\\\\\\"YAHOO.util.Event._tryPreloadAttach()\\\\\\\"\\\",\\n	',',\\n	\\\" 50);\\\\n					 \\\",\\n	\\\"}\\\",\\n	\\\"\\\\n				\\\",\\n	\\\"}\\\",\\n	',',\\n	\\\"\\\\n\\\\n				/**\\\\n				 * Removes all listeners registered by pe.event.  Called \\\\n				 * automatically during the unload event.\\\\n				 */\\\\n				_unload: function(e\\\",\\n	',',\\n	\\\" me) {\\\\n					 for (var i=0; i < unloadListeners.length; ++i) {\\\\n						  var l = unloadListeners[i];\\\\n						  if (l) {\\\\n								var scope = (l[this.ADJ_SCOPE]) ? l[this.SCOPE]: window;\\\\n								l[this.FN].call(scope\\\",\\n	',',\\n	\\\" this.getEvent(e)\\\",\\n	',',\\n	\\\" l[this.SCOPE] );\\\\n						  \\\",\\n	\\\"}\\\",\\n	\\\"\\\\n					 \\\",\\n	\\\"}\\\",\\n	\\\"\\\\n\\\\n					 if (listeners && listeners.length > 0) {\\\\n						  for (i = 0; i < listeners.length; ++i) {\\\\n								l = listeners[i];\\\\n								if (l) {\\\\n									 this.removeListener(l[this.EL]\\\",\\n	',',\\n	\\\" l[this.TYPE]\\\",\\n	',',\\n	\\\" \\\\n												l[this.FN]);\\\\n								\\\",\\n	\\\"}\\\",\\n	\\\"\\\\n						  \\\",\\n	\\\"}\\\",\\n	\\\"\\\\n\\\\n						  this.clearCache();\\\\n					 \\\",\\n	\\\"}\\\",\\n	\\\"\\\\n\\\\n					 for (i = 0; i < customEvents.length; ++i) {\\\\n						  customEvents[i].unsubscribeAll();\\\\n						  delete customEvents[i];\\\\n					 \\\",\\n	\\\"}\\\",\\n	\\\"\\\\n\\\\n					 for (i = 0; i < legacyEvents.length; ++i) {\\\\n						  // dereference the element\\\\n						  delete legacyEvents[i][0];\\\\n						  // delete the array item\\\\n						  delete legacyEvents[i];\\\\n					 \\\",\\n	\\\"}\\\",\\n	\\\"\\\\n				\\\",\\n	\\\"}\\\",\\n	',',\\n	\\\"\\\\n\\\\n				/**\\\\n				 * Returns scrollLeft\\\\n				 * @private\\\\n				 */\\\\n				_getScrollLeft: function() {\\\\n					 return this._getScroll()[1];\\\\n				\\\",\\n	\\\"}\\\",\\n	',',\\n	\\\"\\\\n\\\\n				/**\\\\n				 * Returns scrollTop\\\\n				 * @private\\\\n				 */\\\\n				_getScrollTop: function() {\\\\n					 return this._getScroll()[0];\\\\n				\\\",\\n	\\\"}\\\",\\n	',',\\n	\\\"\\\\n\\\\n				/**\\\\n				 * Returns the scrollTop and scrollLeft.  Used to calculate the \\\\n				 * pageX and pageY in Internet Explorer\\\\n				 * @private\\\\n				 */\\\\n				_getScroll: function() {\\\\n					 var dd = document.documentElement; db = document.body;\\\\n					 if (dd && dd.scrollTop) {\\\\n						  return [dd.scrollTop\\\",\\n	',',\\n	\\\" dd.scrollLeft];\\\\n					 \\\",\\n	\\\"}\\\",\\n	\\\" else if (db) {\\\\n						  return [db.scrollTop\\\",\\n	',',\\n	\\\" db.scrollLeft];\\\\n					 \\\",\\n	\\\"}\\\",\\n	\\\" else {\\\\n						  return [0\\\",\\n	',',\\n	\\\" 0];\\\\n					 \\\",\\n	\\\"}\\\",\\n	\\\"\\\\n				\\\",\\n	\\\"}\\\",\\n	\\\"\\\\n		  \\\",\\n	\\\"}\\\",\\n	\\\";\\\\n	 \\\",\\n	\\\"}\\\",\\n	\\\"\\\\n	 YAHOO.util.Event = tmp_function();\\\\n\\\\n	 YAHOO.util.Event.on = YAHOO.util.Event.addListener;\\\\n\\\\n	 if (document && document.body) {\\\\n		  YAHOO.util.Event._load();\\\\n	 \\\",\\n	\\\"}\\\",\\n	\\\" else {\\\\n		  YAHOO.util.Event.on(window\\\",\\n	',',\\n	\\\" \\\\\\\"load\\\\\\\"\\\",\\n	',',\\n	\\\" YAHOO.util.Event._load\\\",\\n	',',\\n	\\\"\\\\n					 YAHOO.util.Event\\\",\\n	',',\\n	\\\" true);\\\\n	 \\\",\\n	\\\"}\\\",\\n	\\\"\\\\n\\\\n	 YAHOO.util.Event.on(window\\\",\\n	',',\\n	\\\" \\\\\\\"unload\\\\\\\"\\\",\\n	',',\\n	\\\" YAHOO.util.Event._unload\\\",\\n	',',\\n	\\\"\\\\n					 YAHOO.util.Event\\\",\\n	',',\\n	\\\" true);\\\\n\\\\n	 YAHOO.util.Event._tryPreloadAttach();\\\\n\\\\n\\\",\\n	\\\"}\\\",\\n	\\\"\\\\n\\\",\\n	\\\"}\\\",\\n	\\\"\\\\nyahoo_events_init();\\\";\";\n\";}");

?>